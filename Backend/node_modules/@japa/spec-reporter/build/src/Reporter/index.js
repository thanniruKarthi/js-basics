"use strict";
/*
 * @japa/spec-reporter
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpecReporter = void 0;
const ms_1 = __importDefault(require("ms"));
const path_1 = require("path");
const cliui_1 = require("@poppinss/cliui");
const errors_printer_1 = require("@japa/errors-printer");
/**
 * Pretty prints the tests on the console
 */
class SpecReporter {
    constructor() {
        this.uncaughtExceptions = [];
    }
    /**
     * Returns the icon for the test
     */
    getTestIcon(payload) {
        if (payload.isTodo) {
            return cliui_1.logger.colors.cyan(cliui_1.icons.info);
        }
        if (payload.isFailing) {
            return payload.hasError
                ? cliui_1.logger.colors.magenta(cliui_1.icons.squareSmallFilled)
                : cliui_1.logger.colors.red(cliui_1.icons.cross);
        }
        if (payload.hasError) {
            return cliui_1.logger.colors.red(cliui_1.icons.cross);
        }
        if (payload.isSkipped) {
            return cliui_1.logger.colors.yellow(cliui_1.icons.bullet);
        }
        return cliui_1.logger.colors.green(cliui_1.icons.tick);
    }
    /**
     * Returns the test message
     */
    getTestMessage(payload) {
        const message = typeof payload.title === 'string' ? payload.title : payload.title.expanded;
        if (payload.isTodo) {
            return cliui_1.logger.colors.blue(message);
        }
        if (payload.isFailing) {
            return payload.hasError ? cliui_1.logger.colors.magenta(message) : cliui_1.logger.colors.red(message);
        }
        if (payload.hasError) {
            return cliui_1.logger.colors.red(message);
        }
        if (payload.isSkipped) {
            return cliui_1.logger.colors.yellow(message);
        }
        return cliui_1.logger.colors.grey(message);
    }
    /**
     * Returns the subtext message for the test
     */
    getSubText(payload) {
        if (payload.isSkipped && payload.skipReason) {
            return cliui_1.logger.colors.yellow(payload.skipReason);
        }
        if (!payload.isFailing) {
            return;
        }
        if (!payload.hasError) {
            return cliui_1.logger.colors.magenta(`Test marked with ".fails()" must finish with an error`);
        }
        if (payload.failReason) {
            return cliui_1.logger.colors.magenta(payload.failReason);
        }
        const testErrorMessage = payload.errors.find((error) => error.phase === 'test');
        if (testErrorMessage && testErrorMessage.error) {
            return cliui_1.logger.colors.magenta(testErrorMessage.error.message);
        }
    }
    /**
     * Returns the filename relative from the current working dir
     */
    getRelativeFilename(fileName) {
        return (0, path_1.relative)(process.cwd(), fileName);
    }
    /**
     * Prints the test details
     */
    printTest(payload) {
        const icon = this.getTestIcon(payload);
        const message = this.getTestMessage(payload);
        const indentation = this.currentFileName || this.currentGroupTitle ? '  ' : '';
        const duration = cliui_1.logger.colors.dim(`(${(0, ms_1.default)(payload.duration)})`);
        const retries = payload.retryAttempt && payload.retryAttempt > 1
            ? cliui_1.logger.colors.dim(`(x${payload.retryAttempt}) `)
            : '';
        let subText = this.getSubText(payload);
        subText = subText ? `\n${indentation}  ${subText}` : '';
        console.log(`${indentation}${icon} ${retries}${message} ${duration}${subText}`);
    }
    /**
     * Prints the group name
     */
    printGroup(payload) {
        this.currentFileName = payload.meta.fileName;
        this.currentGroupTitle = payload.title;
        const title = this.currentSuiteName !== 'default'
            ? `${this.currentSuiteName} / ${payload.title}`
            : payload.title;
        const suffix = this.currentFileName
            ? cliui_1.logger.colors.dim(` (${this.getRelativeFilename(this.currentFileName)})`)
            : '';
        console.log(`\n${title}${suffix}`);
    }
    /**
     * Print the aggregate count
     */
    printAggregate(label, count, whitespaceLength) {
        if (count) {
            console.log(cliui_1.logger.colors.dim(`${label.padEnd(whitespaceLength + 2)} : ${count}`));
        }
    }
    /**
     * Print tests summary
     */
    async printSummary(summary) {
        console.log('');
        if (summary.aggregates.total === 0) {
            console.log(cliui_1.logger.colors.bgYellow().black(' NO TESTS EXECUTED '));
            return;
        }
        if (summary.hasError) {
            console.log(cliui_1.logger.colors.bgRed().black(' FAILED '));
        }
        else {
            console.log(cliui_1.logger.colors.bgGreen().black(' PASSED '));
        }
        console.log('');
        const aggregatesWhiteSpace = summary.aggregates.uncaughtExceptions ? 19 : 10;
        this.printAggregate('total', summary.aggregates.total, aggregatesWhiteSpace);
        this.printAggregate('failed', summary.aggregates.failed, aggregatesWhiteSpace);
        this.printAggregate('passed', summary.aggregates.passed, aggregatesWhiteSpace);
        this.printAggregate('todo', summary.aggregates.todo, aggregatesWhiteSpace);
        this.printAggregate('skipped', summary.aggregates.skipped, aggregatesWhiteSpace);
        this.printAggregate('regression', summary.aggregates.regression, aggregatesWhiteSpace);
        this.printAggregate('uncaught exceptions', summary.aggregates.uncaughtExceptions, aggregatesWhiteSpace);
        this.printAggregate('duration', (0, ms_1.default)(summary.duration), aggregatesWhiteSpace);
        if (summary.failureTree.length || this.uncaughtExceptions.length) {
            console.log('');
            console.log('');
        }
        const errorPrinter = new errors_printer_1.ErrorsPrinter();
        /**
         * Printing the errors tree
         */
        for (let suite of summary.failureTree) {
            await errorPrinter.printErrors(suite.name, suite.errors);
            for (let testOrGroup of suite.children) {
                if (testOrGroup.type === 'group') {
                    await errorPrinter.printErrors(testOrGroup.name, testOrGroup.errors);
                    for (let test of testOrGroup.children) {
                        await errorPrinter.printErrors(test.title, test.errors);
                    }
                }
                else {
                    await errorPrinter.printErrors(testOrGroup.title, testOrGroup.errors);
                }
            }
        }
        /**
         * Uncaught exceptions
         */
        await errorPrinter.printErrors('Uncaught exception', this.uncaughtExceptions);
    }
    /**
     * Invoked by the tests runner when tests are about to start
     */
    open(runner, emitter) {
        emitter.on('test:start', (payload) => {
            this.currentFileName = payload.meta.fileName;
            /**
             * Print the group title
             */
            if (this.groupPayload) {
                this.printGroup(this.groupPayload);
                this.groupPayload = undefined;
            }
            /**
             * Display the filename when
             *
             * - The filename exists
             * - The test is not under a group
             * - Test is first in a sequence
             */
            if (payload.meta.fileName && !this.currentGroupTitle && !this.currentTestTitle) {
                console.log(`\n${cliui_1.logger.colors.dim(this.getRelativeFilename(this.currentFileName))}`);
            }
            this.currentTestTitle =
                typeof payload.title === 'string' ? payload.title : payload.title.expanded;
        });
        emitter.on('test:end', (payload) => {
            this.printTest(payload);
            this.currentTestTitle = undefined;
        });
        emitter.on('group:start', (payload) => {
            this.groupPayload = payload;
        });
        emitter.on('group:end', () => {
            this.currentGroupTitle = undefined;
            this.groupPayload = undefined;
        });
        emitter.on('suite:start', (payload) => {
            this.currentSuiteName = payload.name;
        });
        emitter.on('suite:end', () => {
            this.currentSuiteName = undefined;
        });
        emitter.on('uncaught:exception', async (error) => {
            this.uncaughtExceptions.push({ phase: 'test', error });
        });
        emitter.on('runner:end', async () => {
            const summary = runner.getSummary();
            await this.printSummary(summary);
        });
    }
}
exports.SpecReporter = SpecReporter;
